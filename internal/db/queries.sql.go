// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createRawCert = `-- name: CreateRawCert :exec
INSERT INTO certificates(id, cert, key) VALUES ($1, $2, $3)
`

type CreateRawCertParams struct {
	ID   string `json:"id"`
	Cert []byte `json:"cert"`
	Key  []byte `json:"key"`
}

func (q *Queries) CreateRawCert(ctx context.Context, arg CreateRawCertParams) error {
	_, err := q.exec(ctx, q.createRawCertStmt, createRawCert, arg.ID, arg.Cert, arg.Key)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE upn=$1
`

func (q *Queries) DeleteUser(ctx context.Context, upn string) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, upn)
	return err
}

const getDevice = `-- name: GetDevice :one
SELECT id, name, description, model FROM devices WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetDeviceParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

type GetDeviceRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Model       sql.NullString `json:"model"`
}

func (q *Queries) GetDevice(ctx context.Context, arg GetDeviceParams) (GetDeviceRow, error) {
	row := q.queryRow(ctx, q.getDeviceStmt, getDevice, arg.ID, arg.TenantID)
	var i GetDeviceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Model,
	)
	return i, err
}

const getDeviceGroups = `-- name: GetDeviceGroups :many
SELECT groups.id, groups.name FROM groups INNER JOIN group_devices ON group_devices.group_id=groups.id WHERE group_devices.device_id = $1
`

type GetDeviceGroupsRow struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetDeviceGroups(ctx context.Context, deviceID string) ([]GetDeviceGroupsRow, error) {
	rows, err := q.query(ctx, q.getDeviceGroupsStmt, getDeviceGroups, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeviceGroupsRow
	for rows.Next() {
		var i GetDeviceGroupsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevicePolicies = `-- name: GetDevicePolicies :many
SELECT id, name, description, policy_id, group_devices.group_id FROM policies INNER JOIN group_policies ON group_policies.policy_id = policies.id INNER JOIN group_devices ON group_devices.group_id=group_policies.group_id WHERE group_devices.device_id = $1
`

type GetDevicePoliciesRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	PolicyID    sql.NullString `json:"policy_id"`
	GroupID     string         `json:"group_id"`
}

func (q *Queries) GetDevicePolicies(ctx context.Context, deviceID string) ([]GetDevicePoliciesRow, error) {
	rows, err := q.query(ctx, q.getDevicePoliciesStmt, getDevicePolicies, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDevicePoliciesRow
	for rows.Next() {
		var i GetDevicePoliciesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PolicyID,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevices = `-- name: GetDevices :many

SELECT id, name, model FROM devices WHERE id = $1 AND tenant_id = $2 LIMIT $3 OFFSET $4
`

type GetDevicesParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type GetDevicesRow struct {
	ID    string         `json:"id"`
	Name  string         `json:"name"`
	Model sql.NullString `json:"model"`
}

//------ Device Actions
func (q *Queries) GetDevices(ctx context.Context, arg GetDevicesParams) ([]GetDevicesRow, error) {
	rows, err := q.query(ctx, q.getDevicesStmt, getDevices,
		arg.ID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDevicesRow
	for rows.Next() {
		var i GetDevicesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Model); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroup = `-- name: GetGroup :one
SELECT id, name, description FROM groups WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetGroupParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

type GetGroupRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) GetGroup(ctx context.Context, arg GetGroupParams) (GetGroupRow, error) {
	row := q.queryRow(ctx, q.getGroupStmt, getGroup, arg.ID, arg.TenantID)
	var i GetGroupRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getGroups = `-- name: GetGroups :many
SELECT id, name, description FROM groups WHERE tenant_id = $1 LIMIT $2 OFFSET $3
`

type GetGroupsParams struct {
	TenantID string `json:"tenant_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type GetGroupsRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) GetGroups(ctx context.Context, arg GetGroupsParams) ([]GetGroupsRow, error) {
	rows, err := q.query(ctx, q.getGroupsStmt, getGroups, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsRow
	for rows.Next() {
		var i GetGroupsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolicies = `-- name: GetPolicies :many
SELECT id, name, description FROM policies WHERE tenant_id = $1 LIMIT $2 OFFSET $3
`

type GetPoliciesParams struct {
	TenantID string `json:"tenant_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type GetPoliciesRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) GetPolicies(ctx context.Context, arg GetPoliciesParams) ([]GetPoliciesRow, error) {
	rows, err := q.query(ctx, q.getPoliciesStmt, getPolicies, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPoliciesRow
	for rows.Next() {
		var i GetPoliciesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolicy = `-- name: GetPolicy :one
SELECT id, name, description FROM policies WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetPolicyParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

type GetPolicyRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) GetPolicy(ctx context.Context, arg GetPolicyParams) (GetPolicyRow, error) {
	row := q.queryRow(ctx, q.getPolicyStmt, getPolicy, arg.ID, arg.TenantID)
	var i GetPolicyRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRawCert = `-- name: GetRawCert :one

SELECT cert, key FROM certificates WHERE id = $1 LIMIT 1
`

type GetRawCertRow struct {
	Cert []byte `json:"cert"`
	Key  []byte `json:"key"`
}

//------ Certificates
func (q *Queries) GetRawCert(ctx context.Context, id string) (GetRawCertRow, error) {
	row := q.queryRow(ctx, q.getRawCertStmt, getRawCert, id)
	var i GetRawCertRow
	err := row.Scan(&i.Cert, &i.Key)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT upn, fullname, azuread_oid FROM users WHERE upn = $1 LIMIT 1
`

type GetUserRow struct {
	Upn        string         `json:"upn"`
	Fullname   string         `json:"fullname"`
	AzureadOid sql.NullString `json:"azuread_oid"`
}

func (q *Queries) GetUser(ctx context.Context, upn string) (GetUserRow, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, upn)
	var i GetUserRow
	err := row.Scan(&i.Upn, &i.Fullname, &i.AzureadOid)
	return i, err
}

const getUserPermissionLevelForTenant = `-- name: GetUserPermissionLevelForTenant :one
SELECT permission_level FROM tenant_users WHERE user_upn = $1 AND tenant_id = $2
`

type GetUserPermissionLevelForTenantParams struct {
	UserUpn  string `json:"user_upn"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) GetUserPermissionLevelForTenant(ctx context.Context, arg GetUserPermissionLevelForTenantParams) (UserPermissionLevel, error) {
	row := q.queryRow(ctx, q.getUserPermissionLevelForTenantStmt, getUserPermissionLevelForTenant, arg.UserUpn, arg.TenantID)
	var permission_level UserPermissionLevel
	err := row.Scan(&permission_level)
	return permission_level, err
}

const getUserSecure = `-- name: GetUserSecure :one
SELECT fullname, password, mfa_token, tenant_id FROM users WHERE upn = $1 LIMIT 1
`

type GetUserSecureRow struct {
	Fullname string         `json:"fullname"`
	Password sql.NullString `json:"password"`
	MfaToken sql.NullString `json:"mfa_token"`
	TenantID sql.NullString `json:"tenant_id"`
}

func (q *Queries) GetUserSecure(ctx context.Context, upn string) (GetUserSecureRow, error) {
	row := q.queryRow(ctx, q.getUserSecureStmt, getUserSecure, upn)
	var i GetUserSecureRow
	err := row.Scan(
		&i.Fullname,
		&i.Password,
		&i.MfaToken,
		&i.TenantID,
	)
	return i, err
}

const getUserTenants = `-- name: GetUserTenants :many
SELECT id, display_name, primary_domain, description FROM tenants INNER JOIN tenant_users ON tenants.id = tenant_users.tenant_id WHERE tenant_users.user_upn = $1
`

func (q *Queries) GetUserTenants(ctx context.Context, userUpn string) ([]Tenant, error) {
	rows, err := q.query(ctx, q.getUserTenantsStmt, getUserTenants, userUpn)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tenant
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.PrimaryDomain,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInTenant = `-- name: GetUsersInTenant :many
SELECT upn, fullname, azuread_oid FROM users WHERE tenant_id = $1 LIMIT $2 OFFSET $3
`

type GetUsersInTenantParams struct {
	TenantID sql.NullString `json:"tenant_id"`
	Limit    int32          `json:"limit"`
	Offset   int32          `json:"offset"`
}

type GetUsersInTenantRow struct {
	Upn        string         `json:"upn"`
	Fullname   string         `json:"fullname"`
	AzureadOid sql.NullString `json:"azuread_oid"`
}

func (q *Queries) GetUsersInTenant(ctx context.Context, arg GetUsersInTenantParams) ([]GetUsersInTenantRow, error) {
	rows, err := q.query(ctx, q.getUsersInTenantStmt, getUsersInTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersInTenantRow
	for rows.Next() {
		var i GetUsersInTenantRow
		if err := rows.Scan(&i.Upn, &i.Fullname, &i.AzureadOid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInTenantByQuery = `-- name: GetUsersInTenantByQuery :many

SELECT upn, fullname, azuread_oid FROM users WHERE tenant_id = $1 AND (upn || fullname || azuread_oid) LIKE $4 LIMIT $2 OFFSET $3
`

type GetUsersInTenantByQueryParams struct {
	TenantID sql.NullString `json:"tenant_id"`
	Limit    int32          `json:"limit"`
	Offset   int32          `json:"offset"`
	Upn      string         `json:"upn"`
}

type GetUsersInTenantByQueryRow struct {
	Upn        string         `json:"upn"`
	Fullname   string         `json:"fullname"`
	AzureadOid sql.NullString `json:"azuread_oid"`
}

// Once https://github.com/kyleconroy/sqlc/issues/778 is fixed change query to (including the ByQuery one): SELECT upn, fullname, azuread_oid FROM users INNER JOIN tenant_users ON users.upn = tenant_users.user_upn WHERE tenant_users.tenant_id = $1 UNION ALL SELECT upn, fullname, azuread_oid FROM users WHERE tenant_id = $1;
func (q *Queries) GetUsersInTenantByQuery(ctx context.Context, arg GetUsersInTenantByQueryParams) ([]GetUsersInTenantByQueryRow, error) {
	rows, err := q.query(ctx, q.getUsersInTenantByQueryStmt, getUsersInTenantByQuery,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.Upn,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersInTenantByQueryRow
	for rows.Next() {
		var i GetUsersInTenantByQueryRow
		if err := rows.Scan(&i.Upn, &i.Fullname, &i.AzureadOid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newGroup = `-- name: NewGroup :one

INSERT INTO groups(name, tenant_id) VALUES ($1, $2) RETURNING id
`

type NewGroupParams struct {
	Name     string `json:"name"`
	TenantID string `json:"tenant_id"`
}

//------ Group Actions
func (q *Queries) NewGroup(ctx context.Context, arg NewGroupParams) (string, error) {
	row := q.queryRow(ctx, q.newGroupStmt, newGroup, arg.Name, arg.TenantID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const newPolicy = `-- name: NewPolicy :one

INSERT INTO policies(name, tenant_id) VALUES ($1, $2) RETURNING id
`

type NewPolicyParams struct {
	Name     string `json:"name"`
	TenantID string `json:"tenant_id"`
}

//------ Policy Actions
func (q *Queries) NewPolicy(ctx context.Context, arg NewPolicyParams) (string, error) {
	row := q.queryRow(ctx, q.newPolicyStmt, newPolicy, arg.Name, arg.TenantID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const newTenant = `-- name: NewTenant :one
INSERT INTO tenants(display_name, primary_domain) VALUES ($1, $2) RETURNING id
`

type NewTenantParams struct {
	DisplayName   string `json:"display_name"`
	PrimaryDomain string `json:"primary_domain"`
}

func (q *Queries) NewTenant(ctx context.Context, arg NewTenantParams) (string, error) {
	row := q.queryRow(ctx, q.newTenantStmt, newTenant, arg.DisplayName, arg.PrimaryDomain)
	var id string
	err := row.Scan(&id)
	return id, err
}

const newUser = `-- name: NewUser :exec


INSERT INTO users(upn, fullname, password, tenant_id) VALUES ($1, $2, $3, $4)
`

type NewUserParams struct {
	Upn      string         `json:"upn"`
	Fullname string         `json:"fullname"`
	Password sql.NullString `json:"password"`
	TenantID sql.NullString `json:"tenant_id"`
}

// DO NOT RUN THIS FILE. It is used along with sqlc to generate type safe Go from SQL
//------ User & Tenant
func (q *Queries) NewUser(ctx context.Context, arg NewUserParams) error {
	_, err := q.exec(ctx, q.newUserStmt, newUser,
		arg.Upn,
		arg.Fullname,
		arg.Password,
		arg.TenantID,
	)
	return err
}

const newUserFromAzureAD = `-- name: NewUserFromAzureAD :exec
INSERT INTO users(upn, fullname, azuread_oid) VALUES ($1, $2, $3)
`

type NewUserFromAzureADParams struct {
	Upn        string         `json:"upn"`
	Fullname   string         `json:"fullname"`
	AzureadOid sql.NullString `json:"azuread_oid"`
}

func (q *Queries) NewUserFromAzureAD(ctx context.Context, arg NewUserFromAzureADParams) error {
	_, err := q.exec(ctx, q.newUserFromAzureADStmt, newUserFromAzureAD, arg.Upn, arg.Fullname, arg.AzureadOid)
	return err
}

const removeUserFromTenant = `-- name: RemoveUserFromTenant :exec
DELETE FROM tenant_users WHERE user_upn=$1 AND tenant_id=$2
`

type RemoveUserFromTenantParams struct {
	UserUpn  string `json:"user_upn"`
	TenantID string `json:"tenant_id"`
}

func (q *Queries) RemoveUserFromTenant(ctx context.Context, arg RemoveUserFromTenantParams) error {
	_, err := q.exec(ctx, q.removeUserFromTenantStmt, removeUserFromTenant, arg.UserUpn, arg.TenantID)
	return err
}

const scopeUserToTenant = `-- name: ScopeUserToTenant :exec
INSERT INTO tenant_users(user_upn, tenant_id, permission_level) VALUES ($1, $2, $3)
`

type ScopeUserToTenantParams struct {
	UserUpn         string              `json:"user_upn"`
	TenantID        string              `json:"tenant_id"`
	PermissionLevel UserPermissionLevel `json:"permission_level"`
}

func (q *Queries) ScopeUserToTenant(ctx context.Context, arg ScopeUserToTenantParams) error {
	_, err := q.exec(ctx, q.scopeUserToTenantStmt, scopeUserToTenant, arg.UserUpn, arg.TenantID, arg.PermissionLevel)
	return err
}
